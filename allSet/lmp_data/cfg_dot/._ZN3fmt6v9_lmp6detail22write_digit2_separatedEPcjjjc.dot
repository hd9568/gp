digraph "CFG for '_ZN3fmt6v9_lmp6detail22write_digit2_separatedEPcjjjc' function" {
	label="CFG for '_ZN3fmt6v9_lmp6detail22write_digit2_separatedEPcjjjc' function";

	Node0x558416923cc0 [shape=record,color="#b70d28ff", style=filled, fillcolor="#b70d2870" fontname="Courier",label="{entry:\l|  %value.addr.i = alloca i8, align 1\l  %buf.addr = alloca ptr, align 8\l  %a.addr = alloca i32, align 4\l  %b.addr = alloca i32, align 4\l  %c.addr = alloca i32, align 4\l  %sep.addr = alloca i8, align 1\l  %digits = alloca i64, align 8\l  %usep = alloca i64, align 8\l  %len = alloca i64, align 8\l  %tmp = alloca [8 x i8], align 1\l  store ptr %buf, ptr %buf.addr, align 8\l  store i32 %a, ptr %a.addr, align 4\l  store i32 %b, ptr %b.addr, align 4\l  store i32 %c, ptr %c.addr, align 4\l  store i8 %sep, ptr %sep.addr, align 1\l  %0 = load i32, ptr %a.addr, align 4\l  %1 = load i32, ptr %b.addr, align 4\l  %shl = shl i32 %1, 24\l  %or = or i32 %0, %shl\l  %conv = zext i32 %or to i64\l  %2 = load i32, ptr %c.addr, align 4\l  %conv1 = zext i32 %2 to i64\l  %shl2 = shl i64 %conv1, 48\l  %or3 = or i64 %conv, %shl2\l  store i64 %or3, ptr %digits, align 8\l  %3 = load i64, ptr %digits, align 8\l  %mul = mul i64 %3, 205\l  %shr = lshr i64 %mul, 11\l  %and = and i64 %shr, 4222124902318095\l  %mul4 = mul i64 %and, 6\l  %4 = load i64, ptr %digits, align 8\l  %add = add i64 %4, %mul4\l  store i64 %add, ptr %digits, align 8\l  %5 = load i64, ptr %digits, align 8\l  %and5 = and i64 %5, 67553998437089520\l  %shr6 = lshr i64 %and5, 4\l  %6 = load i64, ptr %digits, align 8\l  %and7 = and i64 %6, 4222124902318095\l  %shl8 = shl i64 %and7, 8\l  %or9 = or i64 %shr6, %shl8\l  store i64 %or9, ptr %digits, align 8\l  %7 = load i8, ptr %sep.addr, align 1\l  %conv10 = sext i8 %7 to i64\l  store i64 %conv10, ptr %usep, align 8\l  %8 = load i64, ptr %usep, align 8\l  %shl11 = shl i64 %8, 16\l  %or12 = or i64 3472275519666401328, %shl11\l  %9 = load i64, ptr %usep, align 8\l  %shl13 = shl i64 %9, 40\l  %or14 = or i64 %or12, %shl13\l  %10 = load i64, ptr %digits, align 8\l  %or15 = or i64 %10, %or14\l  store i64 %or15, ptr %digits, align 8\l  store i64 8, ptr %len, align 8\l  %call = call noundef zeroext i1 @_ZN3fmt6v9_lmp6detail13is_big_endianEv()\l  %frombool.i = zext i1 %call to i8\l  store i8 %frombool.i, ptr %value.addr.i, align 1\l  %11 = load i8, ptr %value.addr.i, align 1\l  %tobool.i = trunc i8 %11 to i1\l  br i1 %tobool.i, label %if.then, label %if.else\l|{<s0>T|<s1>F}}"];
	Node0x558416923cc0:s0 -> Node0x558416926920[tooltip="entry -> if.then\nProbability 50.00%" ];
	Node0x558416923cc0:s1 -> Node0x558416926990[tooltip="entry -> if.else\nProbability 50.00%" ];
	Node0x558416926920 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#be242e70" fontname="Courier",label="{if.then:\l|  %arraydecay = getelementptr inbounds [8 x i8], ptr %tmp, i64 0, i64 0\l  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay, ptr align 8\l... %digits, i64 8, i1 false)\l  %arraydecay17 = getelementptr inbounds [8 x i8], ptr %tmp, i64 0, i64 0\l  %arraydecay18 = getelementptr inbounds [8 x i8], ptr %tmp, i64 0, i64 0\l  %add.ptr = getelementptr inbounds i8, ptr %arraydecay18, i64 8\l  %12 = load ptr, ptr %buf.addr, align 8\l  %call19 = call noundef ptr @_ZSt12reverse_copyIPcS0_ET0_T_S2_S1_(ptr noundef\l... %arraydecay17, ptr noundef %add.ptr, ptr noundef %12)\l  br label %if.end\l}"];
	Node0x558416926920 -> Node0x558416927180[tooltip="if.then -> if.end\nProbability 100.00%" ];
	Node0x558416926990 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#be242e70" fontname="Courier",label="{if.else:\l|  %13 = load ptr, ptr %buf.addr, align 8\l  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 8 %digits, i64\l... 8, i1 false)\l  br label %if.end\l}"];
	Node0x558416926990 -> Node0x558416927180[tooltip="if.else -> if.end\nProbability 100.00%" ];
	Node0x558416927180 [shape=record,color="#b70d28ff", style=filled, fillcolor="#b70d2870" fontname="Courier",label="{if.end:\l|  ret void\l}"];
}
